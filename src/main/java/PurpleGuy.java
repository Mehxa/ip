import java.util.ArrayList;
import java.util.Scanner;

/**
 * Runs the main() code for the PurpleGuy program.
 * Implements CRUD functionality for various types of tasks.
 */

public class PurpleGuy {
    public static final String LINE = "\u2500".repeat(50) + "\n";
    // PurpleGuy Design and colours generated by Gemini
    public static final String AFTON_PURPLE = "\u001B[38;2;120;0;200m";
    public static final String DARK_P = "\u001B[48;2;75;0;130m  "; // Deep Purple
    public static final String V_DARK = "\u001B[48;2;48;0;78m  "; // Shadow Purple
    public static final String WHITE = "\u001B[48;2;255;255;255m  ";
    public static final String BLACK = "\u001B[48;2;0;0;0m  ";
    public static final String RESET = "\u001B[0m";
    public static final String S = "  "; //Empty space
    public static final String[] SPRITE = {
        S + S + DARK_P + DARK_P + DARK_P + DARK_P,
        S + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P,
        S + WHITE + BLACK + DARK_P + WHITE + BLACK + DARK_P,
        S + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P,
        S + DARK_P + V_DARK + V_DARK + V_DARK + V_DARK + DARK_P + DARK_P + DARK_P,
        S + S + DARK_P + V_DARK + V_DARK + DARK_P + DARK_P + DARK_P + DARK_P,
        S + S + S + S + S + DARK_P + DARK_P + DARK_P + DARK_P,
        S + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P,
        S + S + S + S + S + DARK_P + DARK_P + DARK_P + DARK_P,
        S + S + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P + DARK_P,
        S + S + S + S + S + DARK_P + DARK_P + DARK_P + DARK_P,
        S + S + S + S + S + DARK_P + DARK_P + DARK_P + DARK_P,
        S + S + S + S + S + DARK_P + S + S + DARK_P,
        S + S + S + S + S + DARK_P + S + S + DARK_P,
        S + S + S + S + S + DARK_P + S + S + DARK_P
    };
    private static Scanner inputScan = new Scanner(System.in);
    private static ArrayList<Task> taskList = new ArrayList<>(100);

    /**
     * Prints the given string in a purple font
     * @param message String to be printed
     */
    public static void aftonSpeech(String message) {
        System.out.println(AFTON_PURPLE + message + RESET);
    }

    /**
     * Validates input given by the user
     * @param caseVars String array of variables derived from the user input
     * @throws AftonException If input is invalid: Missing tag/task name, improper tag/command usage
     */

    public static void validateCommand(String[] caseVars) throws AftonException {
        String command = caseVars[0].toLowerCase();
        // Resolving list first as it is the only command
        // which does not require extra parameters
        if (command.equals("list")) {
            if (caseVars.length > 1) {
                throw new AftonException("Do you think I'm blind? "
                                    + "I don't need your 'extra information' to view my own ledger. "
                                    + "Just say the word and be quiet."
                                    + "\n[HINT]: The 'list' command requires no additional words.");
            }
            if (taskList.isEmpty()) {
                throw new AftonException("There is nothing here to silence. You haven't even started your work. "
                                    + "\n[HINT]: Add a task before trying to list");
            }
            return;
        }

        // Command missing essential information
        if (caseVars.length < 2 || caseVars[1].trim().isEmpty() || caseVars[1].startsWith("/")) {
            // More specific error message for missing index rather than missing name
            if (command.equals("mark") || command.equals("unmark") || command.equals("delete")) {
                throw new AftonException("You're pointing at thin air. Give me a number, or step away. "
                                    + "\n[HINT]: Usage: " + command + " [task index number]");
            }
            throw new AftonException("A hollow entry? Much like those empty suits, "
                                + "it's useless without...something inside. Give it a name."
                                + "\n[HINT]: Try: " + command + " [description] ...");
        }
        String[] details = caseVars[1].trim().split("\\s+(?=/)| ^\\s+ | \\s+");
        int noOfBy = 0;
        int noOfFrom = 0;
        int noOfTo = 0;
        int fromIdx = -1;
        int toIdx = -1;

        for (int i = 0; i < details.length; i++) {
            String detail = details[i].trim();
            if (detail.startsWith("/by")) {
                noOfBy++;
            }
            if (detail.startsWith("/from")) {
                noOfFrom++;
                fromIdx = i;
            }
            if (detail.startsWith("/to")) {
                noOfTo++;
                toIdx = i;
            }
        }

        switch (command) {
        case "todo":
            // Todo command inputted with /by, /from or /to
            if (details.length > 1) {
                throw new AftonException("A simple task shouldn't have extra baggage."
                    + " Keep it clean... like a well-wiped crime scene."
                    + "\n[HINT]: Todo tasks do not use /by, /from, or /to tags.");
            }
            break;

        case "deadline":
            if (noOfFrom > 0 || noOfTo > 0) {
                throw new AftonException("You're confusing a deadline with an event."
                    + " Only one end matters here."
                    + "\n[HINT]: Remove /from and /to. Only use /by.");
            }
            if (noOfBy == 0) {
                throw new AftonException("How disappointing. You forgot the '/by' tag."
                    + " Precision is the difference between a masterpiece and a... mess."
                    + "\n[HINT]: A deadline requires a '/by [time]' marker.");
            }
            if (noOfBy > 1) {
                throw new AftonException("Too many endings? Even I only needed one."
                    + " One /by is enough."
                    + "\n[HINT]: Ensure you only have one '/by' tag.");
            }
            if (details[1].trim().equals("/by")) {
                throw new AftonException("A tag with no data? You're stalling. Tell me *when* the clock stops for "
                    + details[0]
                    + "\n[HINT]: Provide the timing details immediately after the /by tag");
            }
            break;

        case "event":
            if (noOfBy > 0) {
                throw new AftonException("Events don't have deadlines; they have schedules. Lose the /by tag."
                    + "\n[HINT]: Replace '/by' with '/from' and '/to'.");
            }
            if (noOfFrom != 1 || noOfTo != 1) {
                throw new AftonException("The stage is set, but the timing is incomplete."
                    + " I require exactly one start and one end."
                    + "\n[HINT]: Ensure you have exactly one '/from' and one '/to' tag.");
            }
            if (toIdx < fromIdx) {
                throw new AftonException("You're trying to end the show before the curtains even rise?"
                    + " Order is everything."
                    + "\n[HINT]: Place the '/from' tag before the '/to' tag.");
            }

            if (details[1].trim().equals("/from")) {
                throw new AftonException("The stage is set, but the actors have no cues for /from."
                    + " Provide a time, or the curtains stay closed."
                    + "\n[HINT]: Provide the timing details immediately after the /from tag");
            }
            if (details[2].trim().equals("/to")) {
                throw new AftonException("You've started the performance, but left the ending in a void."
                    + " Tell me when /to finish it"
                    + "\n[HINT]: Provide the timing details immediately after the /to tag");
            }
            break;

        case "mark":
            // Fallthrough
            // Mark unmark and delete go through the same validation process
        case "unmark":
            //case "delete":
            if (taskList.isEmpty()) {
                throw new AftonException("There is nothing here to silence. You haven't even started your work. "
                                    + "\n[HINT]: Add a task before trying to " + command);
            }
            try {
                int index = Integer.parseInt(details[0]);
                if (index < 1 || index > taskList.size()) {
                    throw new AftonException("Are you seeing ghosts? That record doesn't exist. Stay within the count."
                    + "\n[HINT]: Enter a number between 1 and " + taskList.size() + ".");
                }
            } catch (NumberFormatException e) {
                throw new AftonException("'" + details[0] + "' is not a number."
                + "I require mathematical precision, not guesswork."
                + "\n[HINT]: Provide a valid integer index.");
            }
            break;
        // Any other unrecognised command
        default:
            throw new AftonException("'" + command + "'? I don't recognize that. Don't waste my time with nonsense. "
            + "\n[HINT]: I only respond to: todo, deadline, event, list, mark, unmark, or delete.");
        }

    }

    /**
     * Lists all valid tasks inputted and stored in the task list.
     */

    public static void listTasks() {
        for (int i = 0; i < taskList.size(); i++) {
            aftonSpeech(String.format("%d.%s", (i + 1), taskList.get(i)));
        }
    }

    /**
     * Executes the command inputted by the user
     * Retrieves details needed from caseVars
     * @param caseVars String array of variables derived from the user input
     */
    public static void runCommand(String[] caseVars) {
        int index;
        String taskName;
        if (caseVars[0].equals("list")) {
            listTasks();
            System.out.println();
            return;
        }
        String[] details = caseVars[1].trim().split("\\s+(?=/)| ^\\s+ | \\s+");
        System.err.println("details: " + String.join(", " , details));
        switch (caseVars[0]) {
        case "mark":
            index = Integer.parseInt(caseVars[1]) - 1;
            Task mTask = taskList.get(index);
            mTask.mark();
            aftonSpeech("Done. It's finally... over. For now.");
            System.out.println(mTask + "\n");
            break;

        case "unmark":
            index = Integer.parseInt(caseVars[1]) - 1;
            Task umTask = taskList.get(index);
            umTask.unmark();
            aftonSpeech("Back again? It seems some things just won't stay buried.");
            System.err.println(umTask + "\n");
            break;

        case "todo":
            taskName = details[0];
            Task td = new ToDo(taskName);
            taskList.add(td);
            aftonSpeech("Another? Let's see how long this one lasts.");
            System.out.println(td);
            aftonSpeech(taskList.size() + " entries remain in your little list now.");
            break;

        case "deadline":
            taskName = details[0];
            Task dlTask = new Deadline(taskName, details[1]
                .replace("/by", "").trim());
            taskList.add(dlTask);
            aftonSpeech("A deadline? How fitting. Time is a luxury most of them didn't have.");
            System.out.println(dlTask);
            aftonSpeech("That's " + taskList.size() + " clocks ticking in the dark");
            break;

        case "event":
            taskName = details[0];
            Task evTask = new Event(taskName,
                details[1].replace("/from", "").trim(),
                details[2].replace("/to", "").trim());
            taskList.add(evTask);
            aftonSpeech("");
            System.err.println(evTask);
            aftonSpeech("That makes " + taskList.size() + " acts to follow.");
            break;

        default:
            listTasks();
            break;
        }
    }
    public static void main(String[] args) {
        for (String body : SPRITE) {
            System.out.println(body + RESET);
        }
        aftonSpeech("You look... familiar. Have we met at the Pizzeria?");
        aftonSpeech("I'm William. But I suppose you have your own names for me.");
        aftonSpeech("Tell me... why are you really here?\n");

        String userInput = inputScan.nextLine();
        while (!userInput.equals("bye")) {
            try {
                if (userInput.trim().isEmpty()) {
                    throw new AftonException("Silence? You wake me only to offer... nothing?"
                    + " Speak, or stay out of my wires."
                    + "\n[HINT]: Type a valid command (todo, deadline, event, mark, unmark).");
                }
                String[] caseVars = userInput.split("\\s+", 2); // To extract command
                validateCommand(caseVars);
                runCommand(caseVars);
            } catch (AftonException e) {
                aftonSpeech(e.getMessage());
            }

            userInput = inputScan.nextLine();
        }
        aftonSpeech("Don't think this is over... I always come back.\n" + LINE);
    }
}
